From ab50d5fcd6a061df8a0d0b17fb780f54cf47f64a Mon Sep 17 00:00:00 2001
From: Carlo Savignano <carlosavignano@aospa.co>
Date: Tue, 25 Oct 2016 18:45:47 +0800
Subject: [PATCH] policy: introduce pocket lock

* Block touch screen and keys inputs when device is in pocket.
* Safe-door to disable pocket lock within long press power button
  if sensors do not behave correctly after PocketManager.isDeviceInPocket()
  returns true.
* Window uses TYPE_SYSTEM_ERROR flag with ensure high
  priority over the lockscreen and other high priority windows.
* Do not illuminate buttons when pocket lock is showing.

Ticket: NOUGAT-15

Change-Id: I21e121c03a978fc2a0640d98a9d693a3e9812e2b
Signed-off-by: Carlo Savignano <carlosavignano@aospa.co>
---
 core/res/res/layout/pocket_lock_view_layout.xml    |  42 +++++
 core/res/res/values/pa_strings.xml                 |  23 +++
 core/res/res/values/pa_symbols.xml                 |   6 +
 .../android/server/policy/PhoneWindowManager.java  | 137 ++++++++++++++--
 .../android/server/policy/pocket/PocketLock.java   | 177 +++++++++++++++++++++
 .../android/server/power/PowerManagerService.java  |   6 +-
 6 files changed, 375 insertions(+), 16 deletions(-)
 create mode 100644 core/res/res/layout/pocket_lock_view_layout.xml
 create mode 100644 core/res/res/values/pa_strings.xml
 create mode 100644 services/core/java/com/android/server/policy/pocket/PocketLock.java

diff --git a/core/res/res/layout/pocket_lock_view_layout.xml b/core/res/res/layout/pocket_lock_view_layout.xml
new file mode 100644
index 0000000..2eca671
--- /dev/null
+++ b/core/res/res/layout/pocket_lock_view_layout.xml
@@ -0,0 +1,42 @@
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:layout_gravity="center"
+    android:gravity="center"
+    android:background="@android:color/black">
+
+    <LinearLayout
+        android:id="@+id/pocket_hint_container"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"
+        android:gravity="center"
+        android:orientation="vertical">
+
+        <ImageView
+            android:id="@+id/pocket_hint_image"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:gravity="center_horizontal"
+            android:padding="10dp"
+            android:src="@android:drawable/ic_lock_lock"
+            android:tint="@android:color/white"
+            android:alpha="1.0"/>
+
+        <TextView
+            android:id="@+id/pocket_hint_message"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:gravity="center_horizontal"
+            android:padding="10dp"
+            android:text="@android:string/pocket_lock_message_long_press"
+            android:textColor="@android:color/white"
+            android:alpha="0.7"/>
+
+    </LinearLayout>
+
+
+</LinearLayout>
diff --git a/core/res/res/values/pa_strings.xml b/core/res/res/values/pa_strings.xml
new file mode 100644
index 0000000..17f6540
--- /dev/null
+++ b/core/res/res/values/pa_strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* //device/apps/common/assets/res/any/strings.xml
+**
+** Copyright (C) 2014, ParanoidAndroid Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- Pocket Lock -->
+    <string name="pocket_lock_message_long_press">Long press power button to interact</string>
+</resources>
diff --git a/core/res/res/values/pa_symbols.xml b/core/res/res/values/pa_symbols.xml
index c074b66..41a9e52 100644
--- a/core/res/res/values/pa_symbols.xml
+++ b/core/res/res/values/pa_symbols.xml
@@ -29,4 +29,10 @@
 
   <!-- Whether notify fingerprint client of successful cancelled authentication -->
   <java-symbol type="bool" name="config_notifyClientOnFingerprintCancelSuccess" />
+
+  <!-- Pocket Lock -->
+  <java-symbol type="layout" name="pocket_lock_view_layout" />
+  <java-symbol type="id" name="pocket_hint_container" />
+  <java-symbol type="id" name="pocket_hint_image" />
+  <java-symbol type="id" name="pocket_hint_message" />
 </resources>
diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java
index 914235d..20ca6a1 100644
--- a/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -100,6 +100,7 @@
 import android.os.UEventObserver;
 import android.os.UserHandle;
 import android.os.Vibrator;
+import android.pocket.IPocketCallback;
 import android.pocket.PocketManager;
 import android.provider.MediaStore;
 import android.provider.Settings;
@@ -155,6 +156,7 @@
 import com.android.server.LocalServices;
 import com.android.server.policy.keyguard.KeyguardServiceDelegate;
 import com.android.server.policy.keyguard.KeyguardServiceDelegate.DrawnListener;
+import com.android.server.policy.pocket.PocketLock;
 import com.android.server.statusbar.StatusBarManagerInternal;
 
 import java.io.File;
@@ -198,6 +200,7 @@
     static final int LONG_PRESS_POWER_GLOBAL_ACTIONS = 1;
     static final int LONG_PRESS_POWER_SHUT_OFF = 2;
     static final int LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM = 3;
+    static final int LONG_PRESS_POWER_HIDE_POCKET_LOCK = 4;
 
     static final int LONG_PRESS_BACK_NOTHING = 0;
     static final int LONG_PRESS_BACK_GO_TO_VOICE_ASSIST = 1;
@@ -747,6 +750,25 @@ public void onDrawn() {
     private final MutableBoolean mTmpBoolean = new MutableBoolean(false);
 
     private PocketManager mPocketManager;
+    private PocketLock mPocketLock;
+    private boolean mPocketLockShowing;
+    private boolean mIsDeviceInPocket;
+    private final IPocketCallback mPocketCallback = new IPocketCallback.Stub() {
+
+        @Override
+        public void onStateChanged(boolean isDeviceInPocket, int reason) {
+            boolean wasDeviceInPocket = mIsDeviceInPocket;
+            if (reason == PocketManager.REASON_SENSOR) {
+                mIsDeviceInPocket = isDeviceInPocket;
+            } else {
+                mIsDeviceInPocket = false;
+            }
+            if (wasDeviceInPocket != mIsDeviceInPocket) {
+                handleDevicePocketStateChanged();
+            }
+        }
+
+    };
 
     private static final int MSG_ENABLE_POINTER_LOCATION = 1;
     private static final int MSG_DISABLE_POINTER_LOCATION = 2;
@@ -1130,11 +1152,15 @@ private void interceptPowerKeyDown(KeyEvent event, boolean interactive) {
             mPowerKeyWakeLock.acquire();
         }
 
+        // Still allow muting call with power button press.
+        boolean blockInputs = mIsDeviceInPocket && (!interactive || mPocketLockShowing);
+
         // Cancel multi-press detection timeout.
         if (mPowerKeyPressCounter != 0) {
             mHandler.removeMessages(MSG_POWER_DELAYED_PRESS);
         }
 
+      if (!blockInputs) {
         // Detect user pressing the power button in panic when an application has
         // taken over the whole screen.
         boolean panic = mImmersiveModeConfirmation.onPowerKeyDown(interactive,
@@ -1143,13 +1169,13 @@ private void interceptPowerKeyDown(KeyEvent event, boolean interactive) {
         if (panic) {
             mHandler.post(mHiddenNavPanic);
         }
-
-        // Latch power key state to detect screenshot chord.
-        if (interactive && !mScreenshotChordPowerKeyTriggered
-                && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
-            mScreenshotChordPowerKeyTriggered = true;
-            mScreenshotChordPowerKeyTime = event.getDownTime();
-            interceptScreenshotChord();
+            // Latch power key state to detect screenshot chord.
+            if (interactive && !mScreenshotChordPowerKeyTriggered
+                    && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                mScreenshotChordPowerKeyTriggered = true;
+                mScreenshotChordPowerKeyTime = event.getDownTime();
+                interceptScreenshotChord();
+            }
         }
 
         // Stop ringing or end call if configured to do so when power is pressed.
@@ -1160,7 +1186,7 @@ private void interceptPowerKeyDown(KeyEvent event, boolean interactive) {
                 // Pressing Power while there's a ringing incoming
                 // call should silence the ringer.
                 telecomManager.silenceRinger();
-            } else if ((mIncallPowerBehavior
+            } else if (!blockInputs && (mIncallPowerBehavior
                     & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0
                     && telecomManager.isInCall() && interactive) {
                 // Otherwise, if "Power button ends call" is enabled,
@@ -1169,14 +1195,17 @@ private void interceptPowerKeyDown(KeyEvent event, boolean interactive) {
             }
         }
 
-        GestureLauncherService gestureService = LocalServices.getService(
-                GestureLauncherService.class);
+
         boolean gesturedServiceIntercepted = false;
-        if (gestureService != null) {
-            gesturedServiceIntercepted = gestureService.interceptPowerKeyDown(event, interactive,
-                    mTmpBoolean);
-            if (mTmpBoolean.value && mGoingToSleep) {
-                mCameraGestureTriggeredDuringGoingToSleep = true;
+        if (!blockInputs) {
+            GestureLauncherService gestureService = LocalServices.getService(
+                    GestureLauncherService.class);
+            if (gestureService != null) {
+                gesturedServiceIntercepted = gestureService.interceptPowerKeyDown(event, interactive,
+                        mTmpBoolean);
+                if (mTmpBoolean.value && mGoingToSleep) {
+                    mCameraGestureTriggeredDuringGoingToSleep = true;
+                }
             }
         }
 
@@ -1372,6 +1401,14 @@ private void powerLongPress() {
             sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
             mWindowManagerFuncs.shutdown(behavior == LONG_PRESS_POWER_SHUT_OFF);
             break;
+        case LONG_PRESS_POWER_HIDE_POCKET_LOCK:
+            mPowerKeyHandled = true;
+            if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) {
+                performAuditoryFeedbackForAccessibilityIfNeed();
+            }
+            hidePocketLock(true);
+            mPocketManager.setListeningExternal(false);
+            break;
         }
     }
 
@@ -1415,6 +1452,9 @@ private int getResolvedLongPressOnPowerBehavior() {
         if (FactoryTest.isLongPressOnPowerOffEnabled()) {
             return LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM;
         }
+        if (mPocketLockShowing) {
+            return LONG_PRESS_POWER_HIDE_POCKET_LOCK;
+        }
         return mLongPressOnPowerBehavior;
     }
 
@@ -5791,6 +5831,13 @@ public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
                     + " policyFlags=" + Integer.toHexString(policyFlags));
         }
 
+        // Pre-basic policy based on interactive and pocket lock state.
+        if (mIsDeviceInPocket && (!interactive || mPocketLockShowing)) {
+            if (keyCode != KeyEvent.KEYCODE_POWER) {
+                return 0;
+            }
+        }
+
         // Basic policy based on interactive state.
         int result;
         boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0
@@ -6721,6 +6768,64 @@ private void finishScreenTurningOn() {
         }
     }
 
+    /**
+     * Perform operations if needed on pocket mode state changed.
+     * @see com.android.server.pocket.PocketService
+     * @see PocketLock
+     * @see this.mPocketCallback;
+     * @author Carlo Savignano
+     */
+    private void handleDevicePocketStateChanged() {
+        final boolean interactive = mPowerManager.isInteractive();
+        if (mIsDeviceInPocket) {
+            showPocketLock(interactive);
+        } else {
+            hidePocketLock(interactive);
+        }
+    }
+
+    /**
+     * Check if we can show pocket lock once requested.
+     * @see com.android.server.pocket.PocketService
+     * @see PocketLock
+     * @see this.mPocketCallback;
+     * @author Carlo Savignano
+     */
+    private void showPocketLock(boolean animate) {
+        if (!mSystemReady || !mSystemBooted || !mKeyguardDrawnOnce
+                || mPocketLock == null || mPocketLockShowing) {
+            return;
+        }
+
+        if (DEBUG) {
+            Log.d(TAG, "showPocketLock, animate=" + animate);
+        }
+
+        mPocketLock.show(animate);
+        mPocketLockShowing = true;
+    }
+
+    /**
+     * Check if we can hide pocket lock once requested.
+     * @see com.android.server.pocket.PocketService
+     * @see PocketLock
+     * @see this.mPocketCallback;
+     * @author Carlo Savignano
+     */
+    private void hidePocketLock(boolean animate) {
+        if (!mSystemReady || !mSystemBooted || !mKeyguardDrawnOnce
+                || mPocketLock == null || !mPocketLockShowing) {
+            return;
+        }
+
+        if (DEBUG) {
+            Log.d(TAG, "hidePocketLock, animate=" + animate);
+        }
+
+        mPocketLock.hide(animate);
+        mPocketLockShowing = false;
+    }
+
     private void handleHideBootMessage() {
         synchronized (mLock) {
             if (!mKeyguardDrawnOnce) {
@@ -7137,6 +7242,8 @@ public void setSafeMode(boolean safeMode) {
     @Override
     public void systemReady() {
         mPocketManager = (PocketManager) mContext.getSystemService(Context.POCKET_SERVICE);
+        mPocketManager.addCallback(mPocketCallback);
+        mPocketLock = new PocketLock(mContext);
 
         mKeyguardDelegate = new KeyguardServiceDelegate(mContext,
                 this::onKeyguardShowingStateChanged);
diff --git a/services/core/java/com/android/server/policy/pocket/PocketLock.java b/services/core/java/com/android/server/policy/pocket/PocketLock.java
new file mode 100644
index 0000000..0e6ea3b
--- /dev/null
+++ b/services/core/java/com/android/server/policy/pocket/PocketLock.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2016 The ParanoidAndroid Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.policy.pocket;
+
+import android.animation.Animator;
+import android.content.Context;
+import android.graphics.PixelFormat;
+import android.os.Handler;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.WindowManager;
+
+/**
+ * This class provides a fullscreen overlays view, displaying itself
+ * even on top of lock screen. While this view is displaying touch
+ * inputs are not passed to the the views below.
+ * @see android.view.WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
+ * @author Carlo Savignano
+ */
+public class PocketLock {
+
+    private final Context mContext;
+    private WindowManager mWindowManager;
+    private WindowManager.LayoutParams mLayoutParams;
+    private Handler mHandler;
+    private View mView;
+    private View mHintContainer;
+    private boolean mAttached;
+    private boolean mAnimating;
+
+    /**
+     * Creates pocket lock objects, inflate view and set layout parameters.
+     * @param context
+     */
+    public PocketLock(Context context) {
+        mContext = context;
+        mHandler = new Handler();
+        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+        mLayoutParams = getLayoutParams();
+        mView = LayoutInflater.from(mContext).inflate(
+                com.android.internal.R.layout.pocket_lock_view_layout, null);
+    }
+
+    public void show(final boolean animate) {
+        if (mAttached) {
+            return;
+        }
+
+        final Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                if (mAnimating) {
+                    mView.animate().cancel();
+                }
+
+                if (animate) {
+                    mView.setAlpha(0.0f);
+                    addView();
+                    mView.animate().alpha(1.0f).setListener(new Animator.AnimatorListener() {
+                        @Override
+                        public void onAnimationStart(Animator animator) {
+                            mAnimating = true;
+                        }
+
+                        @Override
+                        public void onAnimationEnd(Animator animator) {
+                            if (mAnimating) {
+                                mAnimating = false;
+                                mView.setAlpha(1.0f); // just in case
+                            }
+                        }
+
+                        @Override
+                        public void onAnimationCancel(Animator animator) {
+                        }
+
+                        @Override
+                        public void onAnimationRepeat(Animator animator) {
+                        }
+                    }).start();
+                } else {
+                    mView.setAlpha(1.0f);
+                    addView();
+                }
+            }
+        };
+
+        mHandler.post(r);
+    }
+
+    public void hide(final boolean animate) {
+        if (!mAttached) {
+            return;
+        }
+
+        final Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                if (mAnimating) {
+                    mView.animate().cancel();
+                }
+
+                if (animate) {
+                    mView.animate().alpha(0.0f).setListener(new Animator.AnimatorListener() {
+                        @Override
+                        public void onAnimationStart(Animator animator) {
+                            mAnimating = true;
+                        }
+
+                        @Override
+                        public void onAnimationEnd(Animator animator) {
+                            if (mAnimating) {
+                                mAnimating = false;
+                                removeView();
+                            }
+                        }
+
+                        @Override
+                        public void onAnimationCancel(Animator animator) {
+                        }
+
+                        @Override
+                        public void onAnimationRepeat(Animator animator) {
+                        }
+                    }).start();
+                } else {
+                    removeView();
+                }
+            }
+        };
+
+        mHandler.post(r);
+    }
+
+    private void addView() {
+        if (mWindowManager != null) {
+            mWindowManager.addView(mView, mLayoutParams);
+            mAttached = true;
+        }
+    }
+
+    private void removeView() {
+        if (mWindowManager != null) {
+            mWindowManager.removeView(mView);
+            mAnimating = false;
+            mAttached = false;
+        }
+    }
+
+    private WindowManager.LayoutParams getLayoutParams() {
+        mLayoutParams = new WindowManager.LayoutParams();
+        mLayoutParams.format = PixelFormat.TRANSLUCENT;
+        mLayoutParams.height = WindowManager.LayoutParams.MATCH_PARENT;
+        mLayoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
+        mLayoutParams.gravity = Gravity.CENTER;
+        mLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
+        mLayoutParams.flags = WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
+                | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
+                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
+        return mLayoutParams;
+    }
+
+}
diff --git a/services/core/java/com/android/server/power/PowerManagerService.java b/services/core/java/com/android/server/power/PowerManagerService.java
index 6f30507..b085b93 100644
--- a/services/core/java/com/android/server/power/PowerManagerService.java
+++ b/services/core/java/com/android/server/power/PowerManagerService.java
@@ -49,6 +49,7 @@
 import android.os.Trace;
 import android.os.UserHandle;
 import android.os.WorkSource;
+import android.pocket.PocketManager;
 import android.provider.Settings;
 import android.provider.Settings.Secure;
 import android.provider.Settings.SettingNotFoundException;
@@ -1464,6 +1465,8 @@ private void updateButtonBrightnessIfNeededLocked(long now) {
             final boolean awake = mWakefulness == WAKEFULNESS_AWAKE;
             final boolean turnOffByTimeout = now >= mLastUserActivityTime + BUTTON_ON_DURATION;
             final boolean screenBright = (mUserActivitySummary & USER_ACTIVITY_SCREEN_BRIGHT) != 0;
+            final PocketManager pocketManager = (PocketManager) mContext.getSystemService(Context.POCKET_SERVICE);
+            final boolean isDeviceInPocket = pocketManager != null && pocketManager.isDeviceInPocket();
             if (awake && wasOn) {
                 if (turnOffByTimeout || !screenBright || !mButtonBrightnessEnabled) {
                     mButtonsLight.setBrightness(0);
@@ -1471,7 +1474,8 @@ private void updateButtonBrightnessIfNeededLocked(long now) {
                     mButtonsLight.setBrightness(mButtonBrightnessSetting);
                 }
             } else if (awake && !wasOn) {
-                if (mButtonBrightnessEnabled && (mWakefulnessChanging || screenBright) && !turnOffByTimeout) {
+                if (mButtonBrightnessEnabled && !isDeviceInPocket
+                        && (mWakefulnessChanging || screenBright) && !turnOffByTimeout) {
                     mButtonsLight.setBrightness(mButtonBrightnessSetting);
                 }
             } else if (!awake && wasOn) {
